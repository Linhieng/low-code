## 拖拽的思考

左侧放置可拖拽的组件，拖拽组件时，会获取到该组件的默认样式。
当该组件进入画布时，画布会获取到该组件的默认样式，
然后画布中有一个元素会渲染成该组件的影子，
当鼠标在画布中移动（dragover）时，影子也会随之移动。
当可拖拽元素放置（drop）在画布中时，画布会创建一个新的元素。

### 具体算法设计 / 过程描述

注意: 我们要求鼠标始终在影子上面，这样才能够让 dragleave 事件等同于 “拖拽离开画布”。实现方法就是让影子覆盖整个画布。

下面的相关数据，均存储在状态库中。

#### 点击拖拽时

获取元素类型，元素类型有文本、按钮、图片、链接、视频。
获取 width、height
    获取的是对应元素的宽度、高度。
    此时获取的元素宽高属于默认值，是不变的。
    这些宽高会用于 “影子” 的渲染，也会作为新增组件的宽高。
获取 drawTop 、drawLeft。
    画布的 top 和 left。
    这两个值一般不会改变，所以可以在点击拖拽时获取。
获取 drawWidth
    画布的宽度，因为我们要限制内容不能超出画布大小。
    至于画布的高度，无上限。
    这个值一般不会改变，所以可以在点击拖拽时获取。
获取 offsetX、offsetY。
    因为我们不想让鼠标指针贴近影子的边缘，所以我们会需要计算鼠标点击的位置。不过因为这个位置在点击时已经确定了，所以直接在 “点击拖拽” 时获取。
获取 btnWidth、btnHeight
    我们的影子和拖拽的元素是不一样大的，所以还要获取拖拽的元素，也就是 “组件按钮” 的宽高。
    虽然实际中我们的组件按钮宽高是固定的，但还是建议使用 window.getComputedStyle() 获取元素宽高。

#### 拖拽进入画布

这个过程主要就是渲染 “影子”，重点在于影子的边距（top、left）的计算。

在进入画布后，主要变化的就是鼠标的位置，所以在这里我们只需要获取鼠标的相关值就可以了。

获取 pageX、pageY。
    鼠标移动时，要求影子也移动，所以我们会获取鼠标的 pageX、pageY 值。

其他的值已经在点击拖拽时就获取了。
现在，我们可以实现这种效果：尽量保持组件按钮在影子中间。

top = pageY - drawTop - offsetY - (height - btnHeight) / 2
left = pageX - drawLeft - offsetX - (width - btnWidth) / 2

因为后面部分不变，所以可用 topTmp 和 leftTmp 表示
topTmp = drawTop + offsetY + (height - btnHeight) / 2
top = pageY - topTmp
leftTmp = drawLeft + offsetX + (width - btnWidth) / 2
left = pageX - leftTmp

当计算完成后，我们还需要校验一下，因为鼠标刚进入时，组件按钮肯定不在影子中间，还有鼠标移动时，也要确保不让影子移出画布范围。

#### 在画布中放下拖拽元素时

此时我们会创建对应的新元素，然后根据影子的 width、height、top、left 值进行渲染。
至于其他的一些默认样式，则通过类名的方式进行渲染更加方便。
因为配置什么的，不属于 “拖拽” 逻辑，所以这里暂不考虑，注意给新创建的元素一个索引，让后续能够修改该元素的配置即可。

#### 拖拽离开画布时

将影子隐藏起来即可。

## 可配置的设置

数值部分的设置，提供滑轮设置，这样也能限制范围

* width
* height
* top
* left
* z-index
* text 文本内容
* video 视频链接
