## 添加新组件 / 拖拽画布组件时的拖拽实现 + 页面自滚动：

1. 鼠标按下（在组件上）
    标记 `down = true`
    然后为页面添加 pointerMove 和 pointerUp 事件

2. 点击组件后直接松开（单击）
    触发 pointerUp 事件
    此时要删除页面的 pointerMove 和 pointerUp 事件

3. 点击组件后移动（拖拽）
    触发 pointerMove 事件
    第一次触发 pointerMove 事件时，需特殊处理：
        标记 `dragging = true`，并存储拖拽组件。
        如果是新组件的创建，此时还需要创建一个 “克隆” 组件作为拖拽组件。
    根据拖拽元素的样式和鼠标的位置，计算拖拽元素的定位值。
    在这个过程中，可以检测滚动条高度是否需要滚动，画布高度是否需要增加。

4. 移动后松开（放置组件）
    触发 pointerUp 事件
    根据拖拽元素的已有样式和画布的相关样式，计算拖拽元素相对画布的绝对定位值
    删除页面的 pointerMove 和 pointerUp 事件。

5. 高度自适应

    高度自适应，无非就是监控鼠标当前位置是否临近 “触发点”
    当进入 “滚动触发点” 时，让包裹画布的元素滚动滚动条就可以了。
    因为拖拽元素是 `fixed` 定位，所以完全不用考虑拖拽元素的样式。
    这样一来，就很方便了。

## 相对位置的计算

元素拖拽时，可以设置元素的定位方式为 `fixed` 或者 `absolute`。
这两个不同的定位方式，决定了位置计算的不同。
之前我采用的是 `absolute` —— 拖拽元素与画布的绝对定位。
现在我采用的是 `fixed` + `transform` 结合。

`transform` 的使用，也有不同的使用方法：
可以让拖拽时只改变 `transform`，而让 `top` 和 `left` 不同。
也可以反过来，只设置 `transform`，拖拽时改变 `top` 和 `left`。

对于工具栏的拖拽，我采用的是只改变 `transform`。
对于组件的拖拽，我采用的是改变 `top` 和 `left`。

这里来讲解改变 `top` 和 `left` 的计算：

1. 新建组件的计算

新建组件，不需要考虑鼠标点击在组件按钮的哪个位置，只需要确保克隆出来的组件，鼠标在中心。
此时的计算很简单，直接让 `top` 和 `left` 等于鼠标的 `MouseEvent.x` `MouseEvent.y`，
然后设置 `transform : translate(-50%, -50%)`，就可以了。

移动过程中，`top` 和 `left` 始终等于鼠标的 `MouseEvent.x` `MouseEvent.y`。

组件放下时，`top` 的值为当前元素的 `top` 值，减去组件高度的一半，再减去画布上边缘距离视口上边缘的值
减去高度的一半，是为了消除 `translateX(-50%)` 的影响
减去画布上边缘距离视口上边缘的值，是因为组件是相对于画布进行绝对定位，但我们拖拽组件时，组件是相对视口进行定位。
注意：
    `getComputedStyle(drawWrapper).top` 是画布顶部边框距离视口的距离，而决定定位，只相对画布的内容，所以计算出 `getComputedStyle(drawWrapper).top` 后还需要减去画布的边框宽度。
    还有 `getComputedStyle(drawWrapper).top` 的值为负数时，代表画布被滚动条隐藏了一部分。所以我们计算时，不需要考虑画布是否滚动了。
`left` 的计算和 `top` 的计算大同小异

2. 拖拽画布组件的计算

拖拽画布组件的计算，复杂一点点，原因是我们需要获取鼠标点击的位置，和拖拽组件之间的相对距离。
计算出这一点后，其他的计算和新建组件的计算是一致的。

通过 `MouseEvent.y` - `getComputedStyle(dragElement).top` 就可以知道鼠标与拖拽组件之间的相对距离。
计算出两个方向的水平距离后，将他们设置为拖拽组件的偏移量 —— `translate(-${x}px, -${y}px)`。
然后在组件移动时，同样的，直接将 `MouseEvent.y` 赋值给组件的 `top` 就可以了。

当放置组件时，计算方法也是一样的：
将当前拖拽元素的 `top` 值，减去垂直方向的偏移量，再减去画布上边缘距离视口上边缘的值。
减去垂直方向的偏移量，和 “新建组件” 中的减去组件高度的一半，是一样的。“减去组件高度的一半” 其实就是偏移量 50% 的值大小。


## 使用

上面的思路，是我实现后的总结。在实现前也有将想法写下来，但是实现后，还是打算删掉了。只留下实现后的总结就可以了。

最终代码效果是，vue 组件中，只需要监控鼠标在组件上按下这一个事件就可以了，剩下的所有工作都在 dragDataCache 中进行。不过这也让 dragDataCache 中的代码较为 “拥挤”